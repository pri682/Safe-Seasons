//
//  FoundationModelsFeaturesProtocol.swift
//  SafeSeasons
//
//  SRP: Extended Foundation Models capabilities. DIP: protocols for all FM features.
//

import Foundation

// MARK: - Streaming Support

/// Protocol for streaming responses from Foundation Models
protocol StreamingAskUseCaseProtocol: Sendable {
    /// Stream a response to a question, yielding chunks as they're generated
    func streamAsk(question: String, context: AskContext) -> AsyncThrowingStream<String, Error>
}

// MARK: - Guided Generation Structures

/// Structured preparedness plan generated by AI
struct PreparednessPlan: Equatable {
    let disasterType: String
    let steps: [String]
    let supplies: [String]
    let urgencyLevel: String // "Low", "Moderate", "High", "Critical"
}

/// Personalized checklist item
struct PersonalizedChecklistItem: Equatable {
    let name: String
    let priority: String // "critical", "high", "medium", "low"
    let reason: String
}

/// Personalized checklist generated by AI
struct PersonalizedChecklist: Equatable {
    let items: [PersonalizedChecklistItem]
}

/// Question classification result
struct QuestionClassification: Equatable {
    let disasterType: String? // "tornado", "hurricane", "flood", etc.
    let mentionedState: String?
    let urgency: String // "low", "moderate", "high", "emergency"
}

/// Question routing result
struct QuestionRoute: Equatable {
    let category: String // "disaster", "state", "supplies", "evacuation", "general"
    let confidence: Double
    let suggestedData: String? // Which disaster/state to look up
}

/// Prioritized emergency action
struct PrioritizedAction: Equatable {
    let step: String
    let priority: String // "immediate", "urgent", "important", "preparatory"
    let estimatedTime: String?
}

/// Prioritized actions list
struct PrioritizedActions: Equatable {
    let actions: [PrioritizedAction]
}

/// Structured query extracted from natural language
struct PreparednessQuery: Equatable {
    let disasterType: String?
    let state: String?
    let month: String?
    let queryType: String // "tips", "supplies", "steps", "risks"
}

/// User query extraction result
struct UserQueryExtraction: Equatable {
    let mentionedState: String?
    let mentionedDisaster: String?
    let timeReference: String? // "this month", "next week", etc.
    let questionType: String // "how-to", "what-is", "when", "where"
}

// MARK: - Feature Protocols

/// Protocol for guided generation (structured output)
protocol GuidedGenerationUseCaseProtocol: Sendable {
    func generatePreparednessPlan(for question: String, context: AskContext) async throws -> PreparednessPlan
    func generatePersonalizedChecklist(disaster: String, state: String, userProfile: String) async throws -> PersonalizedChecklist
}

/// Protocol for content tagging and classification
protocol ContentTaggingUseCaseProtocol: Sendable {
    func classifyQuestion(_ question: String) async throws -> QuestionClassification
    func routeQuestion(_ question: String) async throws -> QuestionRoute
    func extractQueryInfo(_ question: String) async throws -> UserQueryExtraction
}

/// Protocol for summarization
protocol SummarizationUseCaseProtocol: Sendable {
    func summarizeDisaster(_ disaster: Disaster) async throws -> String
    func summarizePreparednessSteps(_ steps: [String]) async throws -> String
}

/// Protocol for emergency prioritization
protocol EmergencyPrioritizationUseCaseProtocol: Sendable {
    func prioritizeEmergencyActions(disaster: String, context: String) async throws -> PrioritizedActions
}

/// Protocol for natural language to query parsing
protocol QueryParsingUseCaseProtocol: Sendable {
    func parseQuery(_ question: String) async throws -> PreparednessQuery
}

/// Protocol for multi-turn conversation management
protocol ConversationSessionProtocol: Sendable {
    func startSession(context: AskContext)
    func ask(_ question: String) async throws -> String
    func clearSession()
    var hasActiveSession: Bool { get }
}
